.ONESHELL:  # All commands in a recipe run in the same shell
SHELL := /bin/bash

# Raspberry Pi 5 (8GB) pipeline using ONNX Runtime CPU
# Usage examples:
#   make -f Makefile.rpi5 all
#   make -f Makefile.rpi5 DRY_RUN=1 all   # dry-run (print commands only)

# Defaults
EDGE_ROOT ?= $(HOME)/edge-yolo
IMG_SIZE ?= 480
WARMUP ?= 20
ITERS ?= 200
CALIB_COUNT ?= 256
CALIB_SAMPLES ?= $(CALIB_COUNT)
CALIB_SUBSETS ?= val2017
COCO_SUBSETS ?= val2017 annotations
COCO_SIZE_TOL ?= 6
COCO_ALLOW_LARGER ?= 1
COCO_EXTRA ?=

# Writable COCO root detection
COCO_CANDIDATES := $(HOME)/coco $(HOME)/data/coco /data/coco
COCO_ROOT ?= $(shell for d in $(COCO_CANDIDATES); do mkdir -p $$d >/dev/null 2>&1 && test -w $$d && echo $$d && break; done)

ifeq ($(strip $(COCO_ROOT)),)
$(warning No writable COCO root found; set COCO_ROOT explicitly.)
COCO_ROOT := $(HOME)/coco
endif

# Output controls
DRY_RUN ?= 0                 # 1=print commands without executing
QUIET ?= 1                   # 1=less verbose output
# Helper to toggle execution vs print; prefix with @ to avoid make's own echo
RUN := $(if $(filter 1,$(DRY_RUN)),echo ,)
AT := @
PIP_Q := $(if $(filter 1,$(QUIET)),-q,)

VENV := $(EDGE_ROOT)/.venv
PY := $(VENV)/bin/python
PIP := $(VENV)/bin/pip
SCRIPTS_DIR := $(CURDIR)
PROJECT_ROOT := $(abspath $(CURDIR)/..)
PROJECT_RESULTS := $(PROJECT_ROOT)/results/figures

# Helper to ensure venv python (skip when DRY_RUN=1)
define ensure_venv
  if [ "$(DRY_RUN)" = "1" ]; then :; elif [ ! -x $(PY) ]; then \
    echo "[i] Python venv missing; run 'make -f Makefile.rpi5 env' first"; exit 2; fi
endef

.PHONY: env coco-download calib-subset bench consolidate report all dry-all clean-engines

env:
	@echo "[i] Setting up venv in $(EDGE_ROOT)"
	$(AT)$(RUN)mkdir -p $(EDGE_ROOT)
	$(AT)$(RUN)python3 -m venv $(VENV)
	$(AT)$(RUN)$(PY) -m pip install $(PIP_Q) --upgrade pip wheel setuptools
	# base deps (onnxruntime is handled best-effort by the RPi script too)
	$(AT)$(RUN)$(PIP) install $(PIP_Q) ultralytics onnx onnxsim numpy opencv-python tqdm rich
	@echo "[i] venv ready"

coco-download:
	@echo "[i] COCO root: $(COCO_ROOT)  subsets: $(COCO_SUBSETS) tol=$(COCO_SIZE_TOL)% allow_larger=$(COCO_ALLOW_LARGER)"
	$(AT)$(RUN)mkdir -p $(COCO_ROOT)
	$(call ensure_venv)
	$(AT)$(RUN)$(PY) $(SCRIPTS_DIR)/download_coco.py --output-dir $(COCO_ROOT) --subsets $(COCO_SUBSETS) \
		--size-tolerance-pct $(COCO_SIZE_TOL) $(if $(filter 1,$(COCO_ALLOW_LARGER)),--allow-larger,) $(COCO_EXTRA)

calib-subset:
	$(call ensure_venv)
	@echo "[i] Building calib subset -> $(EDGE_ROOT)/calib_images (N=$(CALIB_COUNT))"
	$(AT)$(RUN)cd $(EDGE_ROOT)
	$(AT)$(RUN)$(PY) $(SCRIPTS_DIR)/make_calib_subset.py --coco-root $(COCO_ROOT) --subsets $(CALIB_SUBSETS) \
		--count $(CALIB_COUNT) --out-dir calib_images --deterministic

# Single-precision ONNX Runtime CPU run on Raspberry Pi (writes detector_latency_rpi5_$(IMG_SIZE)_ort.json)
bench:
	$(call ensure_venv)
	@echo "[i] Benchmarking on RPi5 ORT: IMG_SIZE=$(IMG_SIZE) WARMUP=$(WARMUP) ITERS=$(ITERS)"
	$(AT)$(RUN)mkdir -p $(EDGE_ROOT)/logs
	$(AT)$(RUN)cd $(EDGE_ROOT)
	$(AT)$(RUN)if [ "$(QUIET)" = "1" ]; then \
		QUIET=$(QUIET) WARMUP=$(WARMUP) ITERS=$(ITERS) bash $(SCRIPTS_DIR)/10_rpi_yolov8_ort.sh $(EDGE_ROOT) $(IMG_SIZE) \
		  > $(EDGE_ROOT)/logs/rpi5_bench_$(IMG_SIZE).log 2>&1; \
		echo "[i] Bench complete (log=$(EDGE_ROOT)/logs/rpi5_bench_$(IMG_SIZE).log)"; \
	  else \
		QUIET=$(QUIET) WARMUP=$(WARMUP) ITERS=$(ITERS) bash $(SCRIPTS_DIR)/10_rpi_yolov8_ort.sh $(EDGE_ROOT) $(IMG_SIZE); \
	  fi
	$(call ensure_venv)
	@echo "[i] Generating CSV from JSON results"
	$(AT)$(RUN)cd $(EDGE_ROOT)
	$(AT)$(RUN)$(PY) $(SCRIPTS_DIR)/aggregate_latency.py --glob "detector_latency_rpi5_$(IMG_SIZE)_*.json" --out "latency_comparative_$(IMG_SIZE).csv"

consolidate:
	$(call ensure_venv)
	@echo "[i] Consolidating (device=Raspberry Pi 5 (8GB), imgsz=$(IMG_SIZE))"
	$(AT)$(RUN)cd $(EDGE_ROOT)
	$(AT)$(RUN)$(PY) $(SCRIPTS_DIR)/consolidate_edge_report.py \
		--latency-csv "latency_comparative_$(IMG_SIZE).csv" \
		--map-glob "map_metrics_$(IMG_SIZE)_*.json" \
		--device "Raspberry Pi 5 (8GB)" --imgsz $(IMG_SIZE) \
		--out-tex results/figures/edge_inference_report.tex \
		--out-json results/figures/edge_inference_report.json

report: consolidate
	@echo "[i] Report artefacts generated under $(EDGE_ROOT)/results/figures"

clean-engines:
	@echo "[i] Nothing to clean for ORT (no TensorRT engines). Removing previous latency files."
	$(AT)$(RUN)rm -f $(EDGE_ROOT)/detector_latency_rpi5_*_*.json || true
	$(AT)$(RUN)rm -f $(EDGE_ROOT)/latency_comparative_*.csv || true

# Copy consolidated artifacts into the repo for convenience
.PHONY: sync-results
sync-results:
	@echo "[i] Syncing artifacts into repo: $(PROJECT_RESULTS)"
	$(AT)$(RUN)mkdir -p $(PROJECT_RESULTS)
	$(AT)$(RUN)cp -f $(EDGE_ROOT)/results/figures/*.tex $(PROJECT_RESULTS) 2>/dev/null || true
	$(AT)$(RUN)cp -f $(EDGE_ROOT)/results/figures/*.json $(PROJECT_RESULTS) 2>/dev/null || true
	$(AT)$(RUN)cp -f $(EDGE_ROOT)/latency_comparative_*.csv $(PROJECT_RESULTS) 2>/dev/null || true

# Convenience: dry run wrapper
dry-all:
	@$(MAKE) -f $(firstword $(MAKEFILE_LIST)) DRY_RUN=1 all

all: env coco-download calib-subset bench report sync-results
	@echo "[i] Full pipeline complete (RPi5/ORT)"

# Additional maintenance / reset targets

# Extract already-downloaded COCO archives without re-downloading (handles each subset zip if present)
coco-extract:
	@echo "[i] Extracting COCO zips for subsets=$(COCO_SUBSETS) from $(COCO_ROOT)"
	@set -e; for s in $(COCO_SUBSETS); do \
	  z1="$(COCO_ROOT)/$${s}.zip"; z2="$(COCO_ROOT)/downloads/$${s}.zip"; \
	  if [ -f "$$z1" ]; then echo "[i] Unzipping $$z1"; unzip -n -q "$$z1" -d "$(COCO_ROOT)"; \
	  elif [ -f "$$z2" ]; then echo "[i] Unzipping $$z2"; unzip -n -q "$$z2" -d "$(COCO_ROOT)"; \
	  else echo "[w] Zip for subset $$s not found (looked at $$z1 and $$z2)"; fi; \
	done; echo "[i] Extraction complete"

# Remove engines, calibration subset, latency / map / layer coverage artifacts (keeps venv & dataset)
reset-edge:
	@echo "[i] Resetting edge artifacts under $(EDGE_ROOT) (keeping dataset & venv)"
	@rm -rf $(EDGE_ROOT)/calib_images || true
	@rm -f $(EDGE_ROOT)/detector_latency_rpi5_*_*.json || true
	@rm -f $(EDGE_ROOT)/latency_comparative_*.csv || true
	@rm -f $(EDGE_ROOT)/map_metrics_*_*.json || true
	@rm -rf $(EDGE_ROOT)/results/figures || true
	@echo "[i] Edge artifacts cleared"

# Full clean: everything (ENGINES, venv, results) EXCEPT COCO dataset unless FULL_DATA=1
FULL_DATA ?= 0
full-clean:
	@echo "[i] Full clean (EDGE_ROOT=$(EDGE_ROOT)) preserve COCO dataset (FULL_DATA=$(FULL_DATA))"
	@rm -rf $(EDGE_ROOT)/detector_latency_rpi5_*_*.json $(EDGE_ROOT)/latency_comparative_*.csv $(EDGE_ROOT)/map_metrics_*_*.json || true
	@rm -rf $(EDGE_ROOT)/calib_images $(EDGE_ROOT)/results || true
	@if [ -d $(EDGE_ROOT)/.venv ]; then rm -rf $(EDGE_ROOT)/.venv; fi
	@if [ "$(FULL_DATA)" = "1" ]; then echo "[i] Removing COCO dataset at $(COCO_ROOT)"; rm -rf $(COCO_ROOT); fi
	@echo "[i] Full clean complete"

.PHONY += coco-extract reset-edge full-clean
